1. Как вы думаете, чем плохо задание атрибута компонента `key` функцией Math.random()?
Ключи помогают React идентифицировать, какой элемент был изменен, добавлен или удален. 
Ключи должны быть предоставлены элементам внутри массива, чтобы дать им стабильную идентифицируемость.
Метод Math.random() возвращает псевдослучайное число с плавающей запятой из диапазона [0, 1), то есть, от 0 (включительно) до 1 (но не включая 1).
Такой вариант не гарантирует уникальности ключей, а также неудобен с точки зрения читаемости.

2. Как будет выглядеть этот пример из урока, если мы кроме id будем передавать еще один параметр title?
    //...
    
      onClick = (id) => (e) => {
            console.log('Действие на строке ' + id);
            e.preventDefault();
            this.setState({ count: this.state.count + 1 });
        };
    
      render() {
          const {id} = this.props;
          const {count} = this.state;
          return <a href="#" onClick={this.onClick(id)}>click {count}</a>;
      }
    //...


 onClick = (id, title) => (e) => {
            console.log('Действие на строке ' + id);
            e.preventDefault();
            this.setState({ count: this.state.count + 1 });
        };
    
3. В чем отличие VirtualDOM от обычного DOM?
Но DOM никогда не был рассчитан для создания динамического пользовательского интерфейса (UI). 
Манипуляции с ним являются очень ресурсозатратными. 
Виртуальный DOM был создан для решения этих проблем, связанных с необходимостью частого обновления DOM более производительным способом. 
В отличие от DOM, виртуальный DOM не является официальной спецификацией, а представляет собой новый метод взаимодействия с DOM. 
Как и исходный DOM, это объектное представление нашего HTML-документа. 
Но так как это простой объект Javascript, мы можем свободно и часто манипулировать им, не касаясь реального DOM, пока нам это не понадобится.
В конечном итоге мы по-прежнему взаимодействуем с DOM, но делаем это как можно реже и более эффективно.

4. В каком порядке выйдут сообщения в консоли и почему?
    handleChange = () => {
    	console.log('foo');
    
    	this.setState({
    		checked: !this.state.checked, 
    		},
    		()=>{console.log('baz')}
    	);
    	console.log('bar') 
    };

    
5. Какую проблему решает использование рефов?
Иногда перед разработчиком стоят такие задачи как выделение текста, фокус и проигрывание медиа. 
При этом помним, что в React мы напрямую с DOM не взаимодействуем. 
React позволяет сделать это с помощью рефов (refs).
Ситуации, в которых использование рефов является оправданным:
- Управление фокусом, выделение текста или воспроизведение медиа.
- Императивный вызов анимаций.
- Интеграция со сторонними DOM-библиотеками.
Избегайте использования рефов в ситуациях, когда задачу можно решить декларативным способом.

6. Как вы думаете почему вызов методов ребенка из родительского компонента противоречит философии реакта?

7. Можно ли с помощью хука `setRef` передать `ref` дочерним элементам? 

8. Что дает нам использование кастомных хуков?
Иногда может понадобиться сделать специфический хук с более сложной логикой, чем те, что поставляются из коробки. 
Если этот функционал будет повторяться, то логичнее написать кастомный хук