1. Чем отличается класс от объекта? Приведите примеры и того, и другого, отличные от указанных в уроке.
Класс - это только структура, а объекты - это уже конкретные переменные с заполненными полями/свойствами на основе этой структуры.
Пример класса:
class Laptop {
  constructor(brand, model, display, processor) {
    this.brand = brand; 
    this.model = model; 
    this.display = display; 
    this.processor = processor; 
  }
} 

Пример объекта: 
let myLaptop = new Laptop ('Apple', 'MacBook Air', '13', Apple M1); // ноутбук Apple MacBook Air с экраном 13 дюймов и процессором Apple M1

2. Приведите примеры объектно-ориентированного подхода в реальной жизни. 
Спортивный зал может содержать классы:
- инвентарь (наименование, бренд, предназначение, стоимость, количество единиц)
- удобства (тренажерный зал, зал для групповых занятий, зал для единоборств, бассейн, сауна, мужская раздевалка, женская раздевалка)
- филиалы (название, тип, адрес, количество сотрудников)
- сотрудники (ФИО, должность, специализация, зарплата, рабочие часы) 

Приведите примеры объектно-ориентированного подхода в программировании. 
Отзывы на сайте с косметикой (автор, тип кожи, возраст, оценка продукта, текст, дата),
Рекомендации на видеосервисе (активные просмотры/продолжить просмотр, фильмы на основе истории просмотров, популярное на сервисе сейчас, топ 100 по версии IMDb)

3.Что такое конструктор? Самостоятельно изучите и напишите, какие бывают виды конструкторов
Функция-конструктор описывает шаблон, по которому будут создаваться объекты (экземпляры). В основе такого шаблона лежит перечисление свойств и методов, которыми будет обладать объект, созданный на основе единой структуры (класса). 
Функции-конструкторы являются обычными функциями. Но есть два соглашения:
Имя функции-конструктора должно начинаться с большой буквы.
Функция-конструктор должна вызываться при помощи оператора "new".
В JavaScript есть два типа конструкторов:
a. Встроенные конструкторы
Это легкодоступные конструкторы, которые поставляются в комплекте со средой исполнения. 
Пользователь просто должен вызвать их. Примерами встроенных конструкторов являются Array, Date и Object.

b. Пользовательские Конструкторы
Это конструкторы, объявленные и определенные программистом для использования в приложении. 
Программист также может определять свойства и методы своих собственных пользовательских типов. 
Они также известны как пользовательские конструкторы. По соглашению все конструкторы JavaScript заключаются в предложения. 
Это говорит человеку, использующему их, что эта функция должна вызываться с использованием нового ключевого слова.

4.Что выведет код? Почему именно так? 
bike();           // "ninja" - функции не передан параметр, поэтому вызывается глобально заданная переменная name со значением "ninja" 
obj1.bike();      // "pomidor" - аналогично obj1().bike(), т.е this.name становится obj1.name
obj2.bike();      // "site" - то же, что в случае obj1

5.Чем статические свойства и методы отличаются от нестатических? В каких ситуациях они применяются?
Методы и свойства класса, которые не привязаны к конкретному объекту и могут существовать без создания экземпляра и слова new, называются статическими.
Обычно статические методы используются для реализации функций, принадлежащих классу, но не к каким-то конкретным его объектам.
Статические методы также используются в классах, относящихся к базам данных, для поиска/сохранения/удаления вхождений в базу данных.

6. Самостоятельно изучите, что такое геттеры и сеттеры, приведите пример класса с их использованием.
Есть два типа свойств объекта.
Первый тип это свойства-данные (data properties). 
Второй тип свойств - свойства-аксессоры (accessor properties). По своей сути это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта.
Свойства-аксессоры представлены методами: «геттер» – для чтения и «сеттер» – для записи. При литеральном объявлении объекта они обозначаются get и set.
onst secret = new WeakMap();
class User {
	constructor(pName) {
    this.name = pName;
		secret.set(this, {_age: 1}); //кстати, приватные свойства принято писать с нижним подчеркиванием вначале
	}
  displayInfo() {
        document.write("Имя: " + this.name + "; возраст: " + this.age);
  };

  getAge() {
        return _age;
  }
  setAge(age) {
        if(typeof age === "number" && age >0 && age < 110){
            _age = age;
        } else {
            console.log("Недопустимое значение");
        }
   }
};
В конструкторе User объявляется локальная переменная `_age` вместо свойства `age`. Как правило, названия локальных переменных в конструкторах начинаются со знака подчеркивания.
Для того, чтобы работать с возрастом пользователя извне, определяются два метода. Метод `getAge()` предназначен для получения значения переменной _age. Этот метод еще называется геттер (getter). 
Второй метод - `setAge`, который еще называется сеттер (setter), предназначен для установки значения переменной _age.
Плюсом такого подхода является то, что мы имеем больший контроль над доступом к значению _age. 
Например, мы можем проверить какие-то сопутствующие условия, как в данном случае проверяются тип значение (он должен представлять число), само значение (возраст не может быть меньше 0).

7. Что выведет код? Почему именно так?
// object, т.к. member создан на основе класса, а класс — это шаблон, описывающий свойства и методы, которыми будет обладать любой объект, созданный на основе этого класса. 

8. Что выведет код? Почему именно так?
name: 'Valera', age: 23 - потому что значение city было перезаписано, финальное значение - "Amsterdam"




