1. Кратко опишите основные отличия `state` от `props`. 
Пропсы нельзя изменять. Они приходят извне.
Состояние хранит такие объекты, которые создаются в компоненте и полностью зависят от компонента.

2. Какую ошибку я допустила в следующем коде и как ее исправить:

    handleChange = () => {
        const chechedArr = this.state.arr; // [1,2,3] 
    		chechedArr.push(5); // [1,2,3,5] 
        this.setState({
          arr: chechedArr,
        });
      };

checkedArr  ;)
Состояния компонентов ни в коем случае нельзя менять напрямую, а мы тут делаем push и мутируем массив
Вариант решения: 
handleChange = () => {
    const chechedArr = [...this.state.arr]; // [1,2,3] 
		chechedArr.push(5); // [1,2,3,5] 
    this.setState({
      arr: chechedArr,
    });
  };
 
3. Можно ли повесить на один элемент несколько обработчиков событий?
Да

4. Каким образом можно изменить `state`?
Влиять на state извне можно только на стадии инициализации, остальное время это делается внутренними методами компонента, например setState

5. Попробуйте предсказать какие сообщения будут в консоли и объяснить результат:
    
    handleChange = () => {
        console.log(this.state.checked) //#1 false 
        this.setState({
          checked: !this.state.checked,
        });
        console.log(this.state.checked) //#2 ?
      };  

Будет false и false
setState - асинхронная функция, а значит она выполнится уже только после того как выполнится #2. 
    
6. Какими способами можно задать функцию `handleChange` и какой из них является самым правильным?
Если мы работаем с классом, то логично было бы использовать такой стиль определения:
handleChange() {
    const { checked } = this.state;
    this.setState({ checked: !checked });
  };
Но такой подход плохо работает в React по двум причинам:
1) У обычных и стрелочных функций по-разному определяется this. 
С таким определением придется постоянно писать подобный код:  
onClick={this.handleClick.bind(this)}
/*** или так ***/
onClick={() => this.handleClick()}
2) Оба предыдущих примера передачи обработчика порождают при каждом вызове функции render новые обработчики, что негативно сказывается на производительности

Поэтому правильный способ определения - стрелочная функция:
handleClick = () => {
const text = 'Hello world!';
    this.setState({ text });
  };

или 

const [checked, setChecked] = useState(props.checked || false);

    const handleChange = () => {
        setChecked(!checked);
    }; // для функционального компонента

7. Чем отличаются классовые и функциональные компоненты? 
Главное отличие классового компонента от функционального это возможность хранить внутреннее состояния. 
Начальное состояние, с которым будет инициализирован компонент после отрисовки, определяется в методе constructor().
Для работы this в callback обязательна привязка bind.
Классовый компонент должен содержать метод render() (у функционального есть только return), который возвращает React-элемент.
Доступ к props осуществляется через this. props.
Захват состояния — также одно из фундаментальных различий классовых и функциональных компонентов. 
Оно заключается в том, что функциональные компоненты захватывают отрендеренные значения.

Какие из них предпочтительнее в 2021 году?
Функциональные

8. Есть ли `this` в функциональных компонентах? 
Нет
Как можно получить к нему доступ?
В функциональном компоненте нам недоступен this, поэтому мы не можем задать или считать состояние через this.state. 
Вместо этого мы вызываем хук useState напрямую изнутри нашего компонента. В useState  мы передаем исходное состояние. 
Вызов useState вернёт пару значений: текущее состояние и функцию, обновляющую состояние

9. Можно ли использовать `props` и `state` одновременно?
Да

10. Где можно задать `state` без использования команды `this.setState`?
На этапе инициализации

11. Может ли состояние классового компонента не быть объектом? 
Нет
А функционального?
В отличие от случая с классами, состояние может быть и не объектом, а строкой или числом, если нам так удобно.

12. Способны ли функциональные компоненты самостоятельно хранить состояние?
Да, с приходом хуков, у функциональных компонентов появилась возможность хранить состояния, использовать методы жизненного цикла, и быть полноценными конкурентами классовых. 
Раньше, если вы писали функциональный компонент и осознавали, что вам нужно наделить его состоянием, вам приходилось превращать этот компонент в класс. 
Теперь же вы можете использовать хук внутри существующего функционального компонента.
Хук — это специальная функция, которая позволяет «подцепиться» к возможностям React. 
Например, хук `useState` предоставляет функциональным компонентам доступ к состоянию React.

13. Как использовать хуки в классовых компонентах?
Хуки доступны только в функциональных компонентах

14. А как задать начальное состояние `props`, если они еще не были переданы?
Использовать дефолтное значение:
static defaultProps = {
        name: 'Hello!',
    };