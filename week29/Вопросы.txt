1. В компонент передаются атрибуты `description` и `title` . 
Могу ли я их сложить как на примере, чтобы получить одну строку и вывести в компоненте?
    import React from "react";
    import styles from './button.css'
    
    export default class Example extends React.Component {
        render() {
    				let {id,title} = this.props
    				title += description;
             return (
                <span>{title}</span>
            );
        }
    }
Нет, т.к. этот пример меняет пропс внутри компонента, а это запрещено
    
2. С помощью какого метода можно отловить изменение `props`?
shouldComponentUpdate()
Он получает аргументы nextProps и nextState и выполняет сравнение с текущим значением props.

3. Оператор расширения часто используется также для клонирования объекта. 
Подумайте, чем отличаются эти две записи и какую проблему решает здесь оператор расширения:
    const initialObj = { title:'Hello', text:'World' }
    
    //№1
    const firstObj = initialObj
    
    //№2
    const secondObj = {...initialObj}

Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке».
Поэтому в первом варианте, мы копируем ссылку на объект, сам же объект не дублируется.
Решить это можно, создав независимую копию объекта. Один из возможных методов - использовать спред оператор(второй вариант).
Таким образом, при изменении secondObj мы не будем мутировать initialObj.
    
4. В каком из методов жизненного цикла лучше всего использовать методы вызова API и обращения к веб-хранилищам, если они должны быть вызваны всего один раз при загрузке страницы?
При монтировании компонента в componentDidMount()

5. С помощью какого метода можно отловить и отрисовать для пользователя возникшую в компоненте ошибку?
componentDidCatch()

6. Какой код обычно пишут в конструкторе? Для каких задач он используется?
В конструкторе устанавливается состояние (state) и пропсы (props).
Эта фаза используется для создания любых свойств (переменные начинающиеся с this.) или инициализации состояния компонента на основе полученных props.
Конструкторы в React обычно используют для двух целей:
- Инициализация внутреннего состояния через присвоение объекта `this.state`
- Привязка обработчиков событий к экземпляру

7. Что делает функция `render`()? Что может ее вызвать?
`render`() перерисовывает компонент. 
Компонент может перерисовываться (то есть, вызывать функцию `render()`) по разным причинам, и в зависимости от причины - вызываются различные функции.
- Создание компонента
- Произошла перерисовка родительского компонента
- В связи с внутренними изменениями
- В связи с вызовом this.forceUpdate
- В связи с перехватом ошибки

8. Что нужно изменить в коде из урока (видео), чтобы начальные параметры у компонента приходили из пропсов, но если пропсы вообще не заданы, начальные значения были инициализированы нулями?
    class Timer extends React.Component {
    	constructor(props) {
    		super(props);
    		this.state = {
    			minutes: 0,
    			seconds: 0
    		};
    	}
    }

Инициализировать состояния компонента на основе полученных props, установить default props равные 0:
class Timer extends React.Component {
  static defaultProps = {
    minutes: 0,
    seconds: 0,
  };
  constructor(props) {
    super(props);
    this.state = {
      minutes: props.minutes,
      seconds: props.seconds,
    };
  }

  render() {
    return (
      <div>
        Timer info: {this.state.minutes}: {this.state.seconds}
      </div>
    );
  }
}
    
9. Можно ли несколько раз использовать хук `useEffect` внутри одного компонента?
Да
Точно так же, как вы можете использовать хук состояния более одного раза, вы можете использовать и несколько эффектов. 
Это даёт нам возможность разделять разную несвязанную между собой логику между разными эффектами.
React будет выполнять каждый используемый эффект в компоненте, согласно порядку их объявления.

10. Можно ли не передавать второй аргумент в хук `useEffect`, что  тогда произойдет?
Второй аргумент необязательный. 
По умолчанию `useEffect` будет выполняться после каждого рендера и обновления. 
Если вторым аргументом передать пустой массив, то вызов функции произойдет только один раз после монтирования.
Мы можем также явно указать, при изменении каких параметров вызывать функцию эффекта.  
Для этого вторым нужно передать массив с этими параметрами.

11. Что означает возвращение функции в теле эффекта? 
Если ваш эффект возвращает функцию, React выполнит её только тогда, когда наступит время сбросить эффект.
В таком случае, мы можем вернуть функцию в теле эффекта, а вторым аргументом передать пустой массив, и получить метод componentWillUnmount, который вызовется только один раз перед размонтированием компонента.
const FunctionalComponent = () => {
 React.useEffect(() => {
   return () => {                   // возвращаем функцию в теле эффекта
     console.log("Bye");
   };
 }, []);
 return <h1>Bye, World</h1>;
}

12. Будут ли перерисованы дочерние элементы компонента при вызове метода `forceUpdate`()?
Вызов `forceUpdate()` приведёт к выполнению метода `render()` в компоненте, пропуская `shouldComponentUpdate()`. 
Это вызовет обычные методы жизненного цикла для дочерних компонентов, включая `shouldComponentUpdate()` каждого дочернего компонента. 
React по-прежнему будет обновлять DOM только в случае изменения разметки.
