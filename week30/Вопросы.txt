1. Если в этом примере, изменить порядок Route таким образом:
    <Routes>
    	<Route path="/" element={<Home />} />
    	<Route path="/about" element={<About/>} />
    	<Route path="/users" element={<Users />} />
    </Routes>
    
    То какой компонент будет отрисован по адресу /users? Объясните почему.

Users, т.к. обертка в </Routes> говорит о том, что используется версия Reacy Router выше 6.0.0.
Последовательность, в которой перечислены  `<Route>` , не имеет значения, так как компонент `<Routes>` умный и нарисует самый подходящий путь. 
В примере выше путь /users попадает под роут / и /users. Но поскольку второй путь подходит лучше, то нарисуется именно он.
    
2. Какое сообщение появится на экране по адресу http://localhost:3000/users/12345
    
    ...
    <Route path='/users/:number' element={<User />} />
    ...
    
    function User(props) {
        const number = props.match.params.number;
        return(
            number===12345
                ? <h1>Моя личная страница</h1>
                : <h1>Страница пользователя {number}</h1>
        );
    }

Моя личная страница
    
3. Вспомните, какой второй параметр принимает метод `map` 
Индекс элемента массива

4. Как бы вы подошли к решению задачи по выводу компонентом `<CardList>` только тех экземпляров компонента `<Card>`, цена которых не превышает заданную?
Использовала бы метод filter:
 {shoes.filter((item) => item.price <= *some price*).map((item, index)=> {
return (
<Card
	key={index}
	id={item.id}
	title={item.title}
	price={item.price}
	description={item.description}
	imgLink={item.imgLink}
  />
)
})}

5. Как задать параметр в пути? Например, filter
1) Мы можем сделать это, добавив параметр в prop path:
<Route path='/users/:filter' element={<Users />} /> 
:filter часть строки в /users/:filter означает, что часть path после /users/ будет получена в виде переменной и сохранится в match.params.number. 

2) Хук 
useLocation возвращает объект, в котором есть поля path и search
С помощью хука useSearchParams можно взять изначальный адрес (searchParams) и его дописать (setSearchParams):
setSearchParams({ filter: *some filter* });

Два варианта отличаются логикой: 
первый используется, когда необходимо менять адрес динамически и происходит полный ререндер страницы, второй - когда страница не меняется, но происходит смена некоторого параметра в адресе и на странице

6. Какая разница между `element` и `children` в указании роутера?
Element - тот компонент, который отвечает за обработку запроса по маршруту, отображает компонент, если путь сопоставляется
Свойство children будет всегда отображаться  - независимо от того сопоставляется ли path или нет.

7. Зачем нужен `exact`?
Это строгая проверка пути во избежание потенциальных ошибок.
Если установлено свойство exact, то отрисуется только строгое сравнение '/about' или '/about/', но не  '/about/chapter1'

8. Cамостоятельно разберитесь, зачем нужны *match*, *location* и *history*? 
history -  "история" (history) и "объект истории" (history object) являются ссылками на пакет history, одну из двух зависимостей React Router (вторая - сам React), представляющий собой несколько реализаций, позволяющих управлять историей сессии с помощью JavaScript в разных окружениях
Позволяет запоминать перемещение пользователя по страницам. 
Объекты истории, как правило, имеют следующие свойства и методы:
- length: number - количество вхождений в стеке истории (history stack)
- action: string - текущая операция (PUSH, REPLACE или POP)
- location
Одним из наиболее часто используемых методов объекта истории является .push(), который перенаправляет вас на другой URL-адрес.
Сейчас устарел, вместо него используется useNavigate.

location - объект истории, текущая локация,  информацию о текущем URL. 
Можно думать о нем как о useState, возвращающем новую локацию при изменении URL. 
Объект локации, в отличие от объекта истории, никогда не мутирует, поэтому его можно использовать для определения того, выполнялась ли навигация, например, для получения данных и запуска анимации.
Может иметь следующие свойства:
- pathname: string - адрес URL
- search: string - строка запроса URL
- hash: string - хэш-фрагмент URL
- state: object - специфичное для локации состояние, переданное, например, с помощью push(path, state) при помещении локации в стек. Доступно только в браузере и истории, хранящейся в памяти
- push(path, [state]): func - помещает новое вхождение в стек истории
- replace(path, [state]): func - заменяет текущее вхождение в стеке истории
- go(n): func - перемещает указатель в стеке истории на n вхождений
- goBack(): func - эквивалент go(-1)
- goForward(): func - эквивалент go(1)
- block(prompt): func - запрещает переход на другую страницу
У объекта местоположения наиболее часто используемым является свойство поиска внутри объекта местоположения. 
В значительной степени означает URL-адрес, но, в частности, параметр строки запроса.
Иногда, когда вы перенаправляете пользователя на другой экран, вы также отправляете дополнительные данные, например, history.push("/addToCart?quantity=99"). 
Здесь мы перенаправляем пользователя на добавление в корзину, но предоставляем дополнительные данные в качестве параметров строки запроса.
function CartScreen({ history, location, match }) {
 const productQuantity = location.search ? 
  parseInt(location.search.split("=")[1])) : 1; 
}
В основном используется в рамках хука useLocation, который возвращает объект

match - объект совпадения (match object) содержит информацию о том, насколько <Route path> совпадает с URL.
Он имеет следующие свойства:
- params: object - пары ключ/значение, соответствующие динамической части URL
- isExact: bool - true, если имеет место совпадение
- path: string - паттерн пути, используемый для поиска совпадения. Используется для построения вложенных <Route>
- url: string - совпавшая часть URL. Используется для создания вложенных <Link>
Обычно свойство, которое используется в match — это свойство params, которое содержит все параметры в URL. 
Например, вы можете быть в localhost:3000/student/student0098. 
В данном случае путь - это /student, а после этого у нас есть идентификатор с именем student0098.
<Route path="/student/:id?" component={StudentScreen} /
function StudentScreen({ history, location, match }) {
  const theStudentId = match.params.id;
  // now place theStudentId in navigation bar or do anything you 
  // want with it.
}
Хук useMatch используется редко (пережиток 5ой версии, но может найти применение в условном рендеринге). 
Он проверяет, что текущий адрес совпадает с location, удобно в том случае, когда нет возможности использовать роутер
Принимает либо строку с путем, либо объект PathPattern (пример: 
interface PathPattern {
  path: string;
  caseSensitive?: boolean;
  end?: boolean;
})

9. Как можно сделать перенаправление на другую страницу по клику на кнопку с помощью `history`? *Ищите ответ в документации к react-router-dom*
Использовать метод  .push() , который перенаправляет на другой URL:
const handleClick = () => {
    history.push("/login"); // now we're in localhost:3000/login
  };
Сейчас устарел, вместо него используется хук useNavigate, который принимает строку или объект и позволяет перенаправлять по клику.
const navigate = useNavigate();
const handleRedirect = () => {
    navigate({
      pathname: '/',
      search: `?${createSearchParams({
        index: state.index,
      })}`,
    });
  };