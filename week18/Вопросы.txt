1. Чем отличаются куки, localStorage и sessionStorage? 
- localStorage позволяет хранить данные внутри всего браузера, т.е. есть возможность переходить между вкладками с сохранением данных,
обладает большей памятью и очищается только вручную с помощью js или очистки кеша браузера, т.е. может храненить данные бессрочно.
- sessionStorage хранит данные только в течении сессии, т.е. данные пропадают, если закрыть вкладку браузера. 
Используется контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные. 
Объём данных больше чем в Cookie.
- cookie обладает очень маленькой памятью (4 Кбайт), но могут быть защищёнными, в этом случае их содержимое нельзя получить на стороне клиента. Это важно при хранении пользовательских данных авторизаци.
Хранит данные, которые можно передавать на сервер через заголовки.
Локальное и сессионное хранилище доступны только на клиентской стороне, а cookie можно передавать на сервер. Срок хранения устанавливается при создании cookie.

Что стоит использовать, если нам нужно надолго сохранить много пользовательских данных?
localStorage

2. Как добавить и получить значение из веб-хранилища? 
localStorage.setItem ('key','value');
localStorage.getItem ('key');
Работа с `sessionStorage` осуществляется аналогично.

3. Придумайте еще минимум 3 ситуации помимо предложенных в уроке, для чего может быть нужно сохранять данные пользователя и какие? 
- запомнить прогресс прохождения, например, курса/теста/просмотра серий в сезоне сериала;
- собирать информацию о посещении сайта/раздела или персональные данные для дальнейшего использования в рамках программы лояльности, маркетинговых активностях и рекламе;
- персонализация настроек сайта (например, отображение выбранных пользователем виджетов, цветовой схемы или размера шрифта);
- сохранение данных для более быстрой повторной загрузки сайта.
    
4. Как сделать валидацию номера кредитной карты? 
С помощью регулярного выражения 
/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/

5. Как сделать input, который будет принимать только числа (минимум 2 способа)?
- через тип Number 
- регулярка с проверкой на число /^\d{1,}$/

6. Найдите регулярное выражение для ФИО на русском языке
([А-ЯЁ][а-яё]+[\-\s]?){3,}

7. Как должно выглядеть невалидное поле, чтобы пользователю было понятно, что в него вводить? 
Подсвечено красным, указано текстовое пояснение ошибки и требования к заполнению поля.
Как показать пользователю, что не так, если ввод некорректен (теги и атрибуты html, псевдоклассы css) ?
*вопрос теоретический, код писать не надо*
Можно использовать встроенную валидацию HTML5 - пометить как required поля, обязательные для заполнения, добавить тип input для е-майла(email), телефона(tel), ссылок(url), текстовых(text) и числовых(number) полей.
Можно также использовать атрибут pattern для соответсвия необходимому регулярному выражению, а также указать ограничение по длине с помощью атрибута maxlength (или minlength для минимальной длины).
Кроме этого существует четыре специальных псевдокласса, применимых к полям формы: :valid (валидное поле), :invalid (невалидное), :required (обязательное) и :optional (необязательное). 
Их можно использовать, чтобы добавлять некоторые — хотя и весьма ограниченные — подсказки пользователям, заполняющим форму.
Стилизация состояний :required и :optional сама по себе не особо полезна, поскольку эта информация обычно указывается в подписях к полям формы. Однако мы можем объединить эти состояния с псевдоклассами :valid / :invalid и стилизовать их комбинации. 
Например, мы хотим показывать лишь положительный результат, когда валидно обязательное к заполнению поле.

Однако лучше использовать JavaScript для улучшения работы пользователей с формами, т.к. возможности HTML5 ограничены и не всегда удобны.
Через объект validity мы можем добавить подсказки на каждый тип ошибки ниже, чтобы пользователю было понятно:
valid: false // Поле валидно 
customError: false // Установленно специальное сообщение ошибки 
patternMismatch: false // Значение не удовлетворяет шаблону, установленному в атрибуте pattern 
rangeOverflow: false // Значение превосходит атрибут max 
rangeUnderflow: true // Значение меньше атрибута min 
stepMismatch: true // Значение не соответствует указаному шагу 
tooLong: false // Значение слишком длинное 
tooShort: false // Значение слишком короткое 
typeMismatch: false // Значение не соответствует указаному атрибуту type 
valueMissing: false // Отсутствует обязательное значение

8. Какие есть недостатки у стандартного способа задания валидации через HTML5?
Ограниченный функционал - проверять мы можем только факт заполнения, но не корректность введенных данных. Также нет возможности кастомизировать всплывающие подсказки. 
Поля, обязательные для заполнения, сразу подсветятся нам как :invalid, а необязательные — как :valid. Это значит, что пользователь, даже не приступив к заполнению формы, может сразу же получить негативную обратную связь. 
